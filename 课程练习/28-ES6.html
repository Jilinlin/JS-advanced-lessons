<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	
</body>
<script>
	//ES6是JS的语法标准
	var username = "zhangsan";
	if(true){
		var username = "lisi";
	}
	console.log(username);//lisi

	//let声明的变量会拥有块级作用域{}
	//用let声明的变量只在 let 命令所在的代码块 { }内有效
	let username = "zhangsan";//全局变量
	if(true){
		let username = "lisi";//不会影响外部
		console.log(username);
	}
	console.log(username);

	function varTest() {
        var x = 31;
        if (true) {
            var x = 71;  // same variable!
            console.log(x);  // 71
        }
        console.log(x);  // 71
    }

    function letTest() {
        let x = 31;
        if (true) {
            let x = 71;  // different variable
            console.log(x);  // 71
        }
        console.log(x);  // 31
    }



	//之前var声明变量的方式，没有块级作用域，只有一个全局变量i，所有的延迟执行共用一个i
	//let声明方式 每次循环都会形成自己的一个独立作用域
	//延迟执行
	for(let i = 0;i<3;i++){
		setTimeout(function(){
			console.log(new Date(),i);
		},i*1000)
	}

	for(var i = 0;i<3;i++){
		setTimeout(function(){
			console.log(new Date(),i);
		},i*1000)
	}

	// const声明常量，也常用来声明不变的函数
	//const声明的变量不可修改 const定义的变量必须进行初始化
	const PI = 3.1415926;
	PI = 3.1212112;

	const sex;

	// var 会进行声明提升，在声明前可以使用该变量
	// 用let声明变量时，在声明前不能使用该变量

	console.log(a);
	var a = 1;
	console.log(a);

	// 等价于
	var a;
	console.log(a);//undefined
	a =1;
	console.log(a);

	console.log(a);
	let a = 1;
	console.log(a);

	// 暂时性死区
	// 只要块级作用域内存在let，它所声明的变量就“绑定”在这个区域，不再受外部影响
    // let对这个块从一开始就形成了封闭的作用域，凡是在声明之前使用该变量，就会报错
    var tmp = 123;
    if(true){
    	tmp = "abc";
    	let tmp;
    }

    // var可以声明重名变量 let和const不可以
    



</script>
</html>